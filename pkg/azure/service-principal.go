package azure

import (
	"azure-ssl-certificate-provisioner/pkg/constants"
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/authorization/armauthorization"
	"github.com/google/uuid"
	"github.com/microsoftgraph/msgraph-sdk-go/applications"
	"github.com/microsoftgraph/msgraph-sdk-go/models"
	"github.com/microsoftgraph/msgraph-sdk-go/serviceprincipals"
	"github.com/spf13/viper"
)

// ServicePrincipalInfo contains Azure service principal information
type ServicePrincipalInfo struct {
	TenantID           string
	ClientID           string
	ClientSecret       string
	UseCertAuth        bool
	PrivateKeyPath     string
	CertificatePath    string
	ApplicationID      string
	ServicePrincipalID string
}

func (sp *ServicePrincipalInfo) GetValue(key string) string {
	switch key {
	case constants.TenantID:
		return sp.TenantID
	case constants.AzureClientID:
		return sp.ClientID
	case constants.AzureClientSecret:
		return sp.ClientSecret
	case constants.PrivateKeyPath:
		return sp.PrivateKeyPath
	case constants.CertificatePath:
		return sp.CertificatePath
	default:
		return viper.GetString(key)
	}
}

// CreateServicePrincipal creates a new Azure AD application and service principal
func CreateServicePrincipal(displayName string, tenantID string) (*ServicePrincipalInfo, error) {
	if displayName == "" {
		return nil, fmt.Errorf("display name is required")
	}

	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID is required")
	}

	// Create the service principal info struct
	spInfo := &ServicePrincipalInfo{
		TenantID:    tenantID,
		UseCertAuth: viper.GetBool(constants.UseCertAuth),
	}

	// Create the Azure AD appDefinition model
	appDefinition := models.NewApplication()
	appDefinition.SetDisplayName(&displayName)

	// Initialize the Microsoft Graph client and create the application
	createdApp, err := GetGraphClient().Applications().Post(context.Background(), appDefinition, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Azure AD application: %v", err)
	}

	if createdApp.GetId() == nil || createdApp.GetAppId() == nil {
		return nil, fmt.Errorf("failed to get application IDs")
	}

	spInfo.ApplicationID = *createdApp.GetId()
	spInfo.ClientID = *createdApp.GetAppId()

	// Create service principal for the application
	servicePrincipal := models.NewServicePrincipal()
	servicePrincipal.SetAppId(createdApp.GetAppId())

	createdSP, err := GetGraphClient().ServicePrincipals().Post(context.Background(), servicePrincipal, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create service principal: %v", err)
	}

	if createdSP.GetId() == nil {
		return nil, fmt.Errorf("failed to get service principal ID")
	}

	spInfo.ServicePrincipalID = *createdSP.GetId()

	if spInfo.UseCertAuth {
		// Derive certificate and private key paths from client ID
		privateKeyPath := fmt.Sprintf("%s.key", spInfo.ClientID)
		certificatePath := fmt.Sprintf("%s.crt", spInfo.ClientID)
		spInfo.PrivateKeyPath = privateKeyPath
		spInfo.CertificatePath = certificatePath

		// Use certificate-based authentication
		err := setupCertificateAuth(spInfo.ApplicationID, privateKeyPath, certificatePath)
		if err != nil {
			return nil, fmt.Errorf("failed to setup certificate authentication: %v", err)
		}
		log.Printf("Certificate authentication configured for application: key=%s, cert=%s", privateKeyPath, certificatePath)
	} else {
		// Create client secret
		passwordCredential := models.NewPasswordCredential()
		displayNameStr := "Generated by azure-ssl-certificate-provisioner"
		passwordCredential.SetDisplayName(&displayNameStr)

		addPasswordRequest := applications.NewItemAddPasswordPostRequestBody()
		addPasswordRequest.SetPasswordCredential(passwordCredential)

		secret, err := GetGraphClient().Applications().ByApplicationId(spInfo.ApplicationID).AddPassword().Post(context.Background(), addPasswordRequest, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to create client secret: %v", err)
		}

		if secret.GetSecretText() == nil {
			return nil, fmt.Errorf("failed to get client secret")
		}

		spInfo.ClientSecret = *secret.GetSecretText()
	}

	subscriptionID := viper.GetString(constants.SubscriptionID)
	resourceGroupName := viper.GetString(constants.ResourceGroupName)

	if subscriptionID == "" || resourceGroupName == "" {
		log.Printf("Subscription ID or Resource Group name not provided; skipping DNS role assignments")
	} else {
		if err := assignDNSZoneContributorRole(spInfo, subscriptionID, resourceGroupName); err != nil {
			log.Printf("DNS Zone Contributor role assignment failed: subscription=%s, resource_group=%s, error=%v", subscriptionID, resourceGroupName, err)
		} else {
			log.Printf("DNS Zone Contributor role assigned: subscription=%s, resource_group=%s", subscriptionID, resourceGroupName)
		}
	}

	keyVaultName := viper.GetString(constants.KeyVaultName)
	keyVaultResourceGroup := viper.GetString(constants.KeyVaultRG)

	if keyVaultName == "" || keyVaultResourceGroup == "" {
		log.Printf("Key Vault name or Resource Group not provided; skipping Key Vault role assignment")
	} else {
		if err := assignKeyVaultCertificatesOfficerRole(spInfo, subscriptionID, keyVaultName, keyVaultResourceGroup); err != nil {
			log.Printf("Key Vault Certificates Officer role assignment failed: subscription=%s, key_vault=%s, error=%v", subscriptionID, keyVaultName, err)
		} else {
			log.Printf("Key Vault Certificates Officer role assigned: subscription=%s, key_vault=%s", subscriptionID, keyVaultName)
		}
	}

	return spInfo, nil
}

func assignDNSZoneContributorRole(spInfo *ServicePrincipalInfo, subscriptionID string, resourceGroupName string) error {
	// DNS Zone Contributor role ID
	dnsZoneContributorRoleID := "/subscriptions/" + subscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/befefa01-2a29-4197-83a8-272ff33ce314"

	// Resource group scope
	scope := "/subscriptions/" + subscriptionID + "/resourceGroups/" + resourceGroupName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &dnsZoneContributorRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	waitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = GetAuthClient().Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("DNS Zone Contributor role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			log.Printf("Principal not found for DNS role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			waitTime *= 2 // Double the wait time for next attempt
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

func assignKeyVaultCertificatesOfficerRole(spInfo *ServicePrincipalInfo, subscriptionID string, keyVaultName, keyVaultResourceGroup string) error {
	// Key Vault Certificates Officer role ID
	keyVaultCertificatesOfficerRoleID := "/subscriptions/" + subscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/a4417e6f-fecd-4de8-b567-7b0420556985"

	// Key Vault scope
	scope := "/subscriptions/" + subscriptionID + "/resourceGroups/" + keyVaultResourceGroup + "/providers/Microsoft.KeyVault/vaults/" + keyVaultName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &keyVaultCertificatesOfficerRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	waitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("Key Vault Certificates Officer role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			log.Printf("Principal not found for Key Vault role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			waitTime *= 2 // Double the wait time for next attempt
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

// DeleteServicePrincipalByClientID deletes an Azure AD application and service principal by client ID
// It also removes all associated role assignments
func DeleteServicePrincipalByClientID(clientID, subscriptionID, tenantID string) error {
	ctx := context.Background()

	// Find the application by client ID
	log.Printf("Looking for Azure AD Application with client ID: '%s'", clientID)

	// Get application directly by client ID using filter
	filter := fmt.Sprintf("appId eq '%s'", clientID)
	apps, err := GetGraphClient().Applications().Get(ctx, &applications.ApplicationsRequestBuilderGetRequestConfiguration{
		QueryParameters: &applications.ApplicationsRequestBuilderGetQueryParameters{
			Filter: &filter,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to get application by client ID: %v", err)
	}

	if apps.GetValue() == nil || len(apps.GetValue()) == 0 {
		return fmt.Errorf("no application found with client ID: '%s'", clientID)
	}

	targetApp := apps.GetValue()[0]
	var applicationID string
	if targetApp.GetId() != nil {
		applicationID = *targetApp.GetId()
	}

	log.Printf("Found application: %s (Client ID: %s)", applicationID, clientID)

	// Find the service principal associated with the application using filter
	spFilter := fmt.Sprintf("appId eq '%s'", clientID)
	servicePrincipalsResult, err := graphClient.ServicePrincipals().Get(ctx, &serviceprincipals.ServicePrincipalsRequestBuilderGetRequestConfiguration{
		QueryParameters: &serviceprincipals.ServicePrincipalsRequestBuilderGetQueryParameters{
			Filter: &spFilter,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to get service principal by client ID: %v", err)
	}

	var servicePrincipalID string
	if servicePrincipalsResult.GetValue() != nil && len(servicePrincipalsResult.GetValue()) > 0 {
		if servicePrincipalsResult.GetValue()[0].GetId() != nil {
			servicePrincipalID = *servicePrincipalsResult.GetValue()[0].GetId()
		}
	}

	if servicePrincipalID != "" {
		log.Printf("Found service principal: %s", servicePrincipalID)

		// Remove role assignments before deleting the service principal
		if err := removeRoleAssignments(servicePrincipalID, subscriptionID); err != nil {
			log.Printf("Warning: Failed to remove some role assignments: %v", err)
		}

		// Delete the service principal
		log.Printf("Deleting service principal...")
		err = graphClient.ServicePrincipals().ByServicePrincipalId(servicePrincipalID).Delete(ctx, nil)
		if err != nil {
			return fmt.Errorf("failed to delete service principal: %v", err)
		}
		log.Printf("Service principal deleted successfully")
	} else {
		log.Printf("No service principal found for application: %s", clientID)
	}

	// Delete the application
	log.Printf("Deleting Azure AD application...")
	err = graphClient.Applications().ByApplicationId(applicationID).Delete(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to delete Azure AD application: %v", err)
	}
	log.Printf("Azure AD application deleted successfully")

	// Clean up local certificate files
	cleanupCertificateFiles(clientID)

	return nil
}

// removeRoleAssignments removes all role assignments for a service principal
func removeRoleAssignments(servicePrincipalID, subscriptionID string) error {
	if subscriptionID == "" {
		return fmt.Errorf("subscription ID is required for role assignment operations")
	}

	log.Printf("Removing role assignments for service principal %s in subscription %s", servicePrincipalID, subscriptionID)

	clientOptions := &arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			APIVersion: "2022-04-01",
		},
	}
	authClient, err := armauthorization.NewRoleAssignmentsClient(subscriptionID, credential, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to create authorization client: %v", err)
	}

	// List all role assignments for the subscription with filter by principal ID
	filter := fmt.Sprintf("principalId eq '%s'", servicePrincipalID)
	pager := authClient.NewListPager(&armauthorization.RoleAssignmentsClientListOptions{
		Filter: &filter,
	})

	var roleAssignmentsToDelete []struct {
		Name  string
		Scope string
	}

	for pager.More() {
		page, err := pager.NextPage(context.Background())
		if err != nil {
			return fmt.Errorf("failed to list role assignments: %v", err)
		}

		for _, assignment := range page.Value {
			if assignment.Properties != nil &&
				assignment.Properties.PrincipalID != nil &&
				*assignment.Properties.PrincipalID == servicePrincipalID {
				if assignment.Name != nil && assignment.Properties.Scope != nil {
					roleAssignmentsToDelete = append(roleAssignmentsToDelete, struct {
						Name  string
						Scope string
					}{
						Name:  *assignment.Name,
						Scope: *assignment.Properties.Scope,
					})
					log.Printf("Found role assignment to remove: %s at scope: %s", *assignment.Name, *assignment.Properties.Scope)
				}
			}
		}
	}

	// Delete each role assignment using the correct scope
	for _, assignment := range roleAssignmentsToDelete {
		_, err := authClient.Delete(context.Background(), assignment.Scope, assignment.Name, nil)
		if err != nil {
			log.Printf("Warning: Failed to delete role assignment %s at scope %s: %v", assignment.Name, assignment.Scope, err)
		} else {
			log.Printf("Role assignment removed: %s at scope: %s", assignment.Name, assignment.Scope)
		}
	}

	return nil
}
