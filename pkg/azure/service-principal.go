package azure

import (
	"azure-ssl-certificate-provisioner/pkg/constants"
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/authorization/armauthorization"
	"github.com/google/uuid"
	"github.com/microsoftgraph/msgraph-sdk-go/applications"
	"github.com/microsoftgraph/msgraph-sdk-go/models"
	"github.com/spf13/viper"
)

// ServicePrincipalInfo contains Azure service principal information
type ServicePrincipalInfo struct {
	TenantID           string
	ClientID           string
	ClientSecret       string
	UseCertAuth        bool
	PrivateKeyPath     string
	CertificatePath    string
	ApplicationID      string
	ServicePrincipalID string
}

func (sp *ServicePrincipalInfo) GetValue(key string) string {
	switch key {
	case constants.TenantID:
		return sp.TenantID
	case constants.AzureClientID:
		return sp.ClientID
	case constants.AzureClientSecret:
		return sp.ClientSecret
	case constants.PrivateKeyPath:
		return sp.PrivateKeyPath
	case constants.CertificatePath:
		return sp.CertificatePath
	default:
		return viper.GetString(key)
	}
}

// CreateServicePrincipal creates a new Azure AD application and service principal
func CreateServicePrincipal(displayName string, tenantID string) (*ServicePrincipalInfo, error) {
	if displayName == "" {
		return nil, fmt.Errorf("display name is required")
	}

	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID is required")
	}

	// Create the service principal info struct
	spInfo := &ServicePrincipalInfo{
		TenantID:    tenantID,
		UseCertAuth: viper.GetBool(constants.UseCertAuth),
	}

	// Create the Azure AD appDefinition model
	appDefinition := models.NewApplication()
	appDefinition.SetDisplayName(&displayName)

	// Initialize the Microsoft Graph client and create the application
	createdApp, err := GetGraphClient().Applications().Post(context.Background(), appDefinition, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Azure AD application: %v", err)
	}

	if createdApp.GetId() == nil || createdApp.GetAppId() == nil {
		return nil, fmt.Errorf("failed to get application IDs")
	}

	spInfo.ApplicationID = *createdApp.GetId()
	spInfo.ClientID = *createdApp.GetAppId()

	// Create service principal for the application
	servicePrincipal := models.NewServicePrincipal()
	servicePrincipal.SetAppId(createdApp.GetAppId())

	createdSP, err := GetGraphClient().ServicePrincipals().Post(context.Background(), servicePrincipal, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create service principal: %v", err)
	}

	if createdSP.GetId() == nil {
		return nil, fmt.Errorf("failed to get service principal ID")
	}

	spInfo.ServicePrincipalID = *createdSP.GetId()

	if spInfo.UseCertAuth {
		// Derive certificate and private key paths from client ID
		privateKeyPath := fmt.Sprintf("%s.key", spInfo.ClientID)
		certificatePath := fmt.Sprintf("%s.crt", spInfo.ClientID)
		spInfo.PrivateKeyPath = privateKeyPath
		spInfo.CertificatePath = certificatePath

		// Use certificate-based authentication
		err := setupCertificateAuth(spInfo.ApplicationID, privateKeyPath, certificatePath)
		if err != nil {
			return nil, fmt.Errorf("failed to setup certificate authentication: %v", err)
		}
		log.Printf("Certificate authentication configured for application: key=%s, cert=%s", privateKeyPath, certificatePath)
	} else {
		// Create client secret
		passwordCredential := models.NewPasswordCredential()
		displayNameStr := "Generated by azure-ssl-certificate-provisioner"
		passwordCredential.SetDisplayName(&displayNameStr)

		addPasswordRequest := applications.NewItemAddPasswordPostRequestBody()
		addPasswordRequest.SetPasswordCredential(passwordCredential)

		secret, err := GetGraphClient().Applications().ByApplicationId(spInfo.ApplicationID).AddPassword().Post(context.Background(), addPasswordRequest, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to create client secret: %v", err)
		}

		if secret.GetSecretText() == nil {
			return nil, fmt.Errorf("failed to get client secret")
		}

		spInfo.ClientSecret = *secret.GetSecretText()
	}

	subscriptionID := viper.GetString(constants.SubscriptionID)
	resourceGroupName := viper.GetString(constants.ResourceGroupName)

	if subscriptionID == "" || resourceGroupName == "" {
		log.Printf("Subscription ID or Resource Group name not provided; skipping DNS role assignments")
	} else {
		if err := assignDNSZoneContributorRole(spInfo, subscriptionID, resourceGroupName); err != nil {
			log.Printf("DNS Zone Contributor role assignment failed: subscription=%s, resource_group=%s, error=%v", subscriptionID, resourceGroupName, err)
		} else {
			log.Printf("DNS Zone Contributor role assigned: subscription=%s, resource_group=%s", subscriptionID, resourceGroupName)
		}
	}

	keyVaultName := viper.GetString(constants.KeyVaultName)
	keyVaultResourceGroup := viper.GetString(constants.KeyVaultRG)

	if keyVaultName == "" || keyVaultResourceGroup == "" {
		log.Printf("Key Vault name or Resource Group not provided; skipping Key Vault role assignment")
	} else {
		if err := assignKeyVaultCertificatesOfficerRole(spInfo, subscriptionID, keyVaultName, keyVaultResourceGroup); err != nil {
			log.Printf("Key Vault Certificates Officer role assignment failed: subscription=%s, key_vault=%s, error=%v", subscriptionID, keyVaultName, err)
		} else {
			log.Printf("Key Vault Certificates Officer role assigned: subscription=%s, key_vault=%s", subscriptionID, keyVaultName)
		}
	}

	return spInfo, nil
}

func assignDNSZoneContributorRole(spInfo *ServicePrincipalInfo, subscriptionID string, resourceGroupName string) error {
	// DNS Zone Contributor role ID
	dnsZoneContributorRoleID := "/subscriptions/" + subscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/befefa01-2a29-4197-83a8-272ff33ce314"

	// Resource group scope
	scope := "/subscriptions/" + subscriptionID + "/resourceGroups/" + resourceGroupName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &dnsZoneContributorRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	waitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = GetAuthClient().Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("DNS Zone Contributor role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			log.Printf("Principal not found for DNS role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			waitTime *= 2 // Double the wait time for next attempt
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

func assignKeyVaultCertificatesOfficerRole(spInfo *ServicePrincipalInfo, subscriptionID string, keyVaultName, keyVaultResourceGroup string) error {
	// Key Vault Certificates Officer role ID
	keyVaultCertificatesOfficerRoleID := "/subscriptions/" + subscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/a4417e6f-fecd-4de8-b567-7b0420556985"

	// Key Vault scope
	scope := "/subscriptions/" + subscriptionID + "/resourceGroups/" + keyVaultResourceGroup + "/providers/Microsoft.KeyVault/vaults/" + keyVaultName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &keyVaultCertificatesOfficerRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	waitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("Key Vault Certificates Officer role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			log.Printf("Principal not found for Key Vault role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			waitTime *= 2 // Double the wait time for next attempt
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}
