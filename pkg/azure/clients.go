package azure

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/keyvault/azcertificates"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/authorization/armauthorization"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/dns/armdns"
	"github.com/google/uuid"
	msgraph "github.com/microsoftgraph/msgraph-sdk-go"
	"github.com/microsoftgraph/msgraph-sdk-go/applications"
	"github.com/microsoftgraph/msgraph-sdk-go/models"

	"azure-ssl-certificate-provisioner/internal/types"
)

// Clients holds Azure service clients
type Clients struct {
	DNS        *armdns.RecordSetsClient
	DNSZones   *armdns.ZonesClient
	KVCert     *azcertificates.Client
	Credential *azidentity.DefaultAzureCredential
	Graph      *msgraph.GraphServiceClient
}

// NewClients creates new Azure service clients
func NewClients(subscriptionID, vaultURL string) (*Clients, error) {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to obtain Azure credential: %v", err)
	}

	dnsClient, err := armdns.NewRecordSetsClient(subscriptionID, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create DNS client: %v", err)
	}

	dnsZonesClient, err := armdns.NewZonesClient(subscriptionID, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create DNS zones client: %v", err)
	}

	kvCertClient, err := azcertificates.NewClient(vaultURL, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Key Vault client: %v", err)
	}

	graphClient, err := msgraph.NewGraphServiceClientWithCredentials(cred, []string{"https://graph.microsoft.com/.default"})
	if err != nil {
		return nil, fmt.Errorf("failed to create Graph client: %v", err)
	}

	return &Clients{
		DNS:        dnsClient,
		DNSZones:   dnsZonesClient,
		KVCert:     kvCertClient,
		Credential: cred,
		Graph:      graphClient,
	}, nil
}

// CreateServicePrincipal creates a new Azure AD application and service principal
func (c *Clients) CreateServicePrincipal(displayName, tenantID, subscriptionID string, assignDNSRole bool, resourceGroupName, keyVaultName, keyVaultResourceGroup string) (*types.ServicePrincipalInfo, error) {
	// Validate provided tenant and subscription IDs
	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID is required")
	}
	if subscriptionID == "" {
		return nil, fmt.Errorf("subscription ID is required")
	}

	// Create the Azure AD application
	application := models.NewApplication()
	application.SetDisplayName(&displayName)

	createdApp, err := c.Graph.Applications().Post(context.Background(), application, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Azure AD application: %v", err)
	}

	applicationID := createdApp.GetId()
	clientID := createdApp.GetAppId()

	if applicationID == nil || clientID == nil {
		return nil, fmt.Errorf("failed to get application IDs")
	}

	// Create service principal for the application
	servicePrincipal := models.NewServicePrincipal()
	servicePrincipal.SetAppId(clientID)

	createdSP, err := c.Graph.ServicePrincipals().Post(context.Background(), servicePrincipal, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create service principal: %v", err)
	}

	servicePrincipalID := createdSP.GetId()
	if servicePrincipalID == nil {
		return nil, fmt.Errorf("failed to get service principal ID")
	}

	// Create client secret
	passwordCredential := models.NewPasswordCredential()
	displayNameStr := "Generated by azure-ssl-certificate-provisioner"
	passwordCredential.SetDisplayName(&displayNameStr)

	addPasswordRequest := applications.NewItemAddPasswordPostRequestBody()
	addPasswordRequest.SetPasswordCredential(passwordCredential)

	secret, err := c.Graph.Applications().ByApplicationId(*applicationID).AddPassword().Post(context.Background(), addPasswordRequest, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create client secret: %v", err)
	}

	clientSecret := secret.GetSecretText()
	if clientSecret == nil {
		return nil, fmt.Errorf("failed to get client secret")
	}

	spInfo := &types.ServicePrincipalInfo{
		ApplicationID:      *applicationID,
		ClientID:           *clientID,
		ClientSecret:       *clientSecret,
		ServicePrincipalID: *servicePrincipalID,
		SubscriptionID:     subscriptionID,
		TenantID:           tenantID,
	}

	// Optionally assign DNS Zone Contributor role
	if assignDNSRole && resourceGroupName != "" {
		if err := c.assignDNSZoneContributorRole(spInfo, resourceGroupName); err != nil {
			log.Printf("DNS Zone Contributor role assignment failed: resource_group=%s, error=%v", resourceGroupName, err)
		} else {
			log.Printf("DNS Zone Contributor role assigned: resource_group=%s", resourceGroupName)
		}
	}

	// Optionally assign Key Vault Certificates Officer role
	if keyVaultName != "" && keyVaultResourceGroup != "" {
		if err := c.assignKeyVaultCertificatesOfficerRole(spInfo, keyVaultName, keyVaultResourceGroup); err != nil {
			log.Printf("Key Vault Certificates Officer role assignment failed: key_vault=%s, error=%v", keyVaultName, err)
		} else {
			log.Printf("Key Vault Certificates Officer role assigned: key_vault=%s", keyVaultName)
		}
	}

	return spInfo, nil
}

func (c *Clients) assignDNSZoneContributorRole(spInfo *types.ServicePrincipalInfo, resourceGroupName string) error {
	clientOptions := &arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			APIVersion: "2022-04-01",
		},
	}
	authClient, err := armauthorization.NewRoleAssignmentsClient(spInfo.SubscriptionID, c.Credential, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to create authorization client: %v", err)
	}

	// DNS Zone Contributor role ID
	dnsZoneContributorRoleID := "/subscriptions/" + spInfo.SubscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/befefa01-2a29-4197-83a8-272ff33ce314"

	// Resource group scope
	scope := "/subscriptions/" + spInfo.SubscriptionID + "/resourceGroups/" + resourceGroupName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &dnsZoneContributorRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	baseWaitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("DNS Zone Contributor role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			waitTime := baseWaitTime * time.Duration(attempt)
			log.Printf("Principal not found for DNS role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

func (c *Clients) assignKeyVaultCertificatesOfficerRole(spInfo *types.ServicePrincipalInfo, keyVaultName, keyVaultResourceGroup string) error {
	clientOptions := &arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			APIVersion: "2022-04-01",
		},
	}
	authClient, err := armauthorization.NewRoleAssignmentsClient(spInfo.SubscriptionID, c.Credential, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to create authorization client: %v", err)
	}

	// Key Vault Certificates Officer role ID
	keyVaultCertificatesOfficerRoleID := "/subscriptions/" + spInfo.SubscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/a4417e6f-fecd-4de8-b567-7b0420556985"

	// Key Vault scope
	scope := "/subscriptions/" + spInfo.SubscriptionID + "/resourceGroups/" + keyVaultResourceGroup + "/providers/Microsoft.KeyVault/vaults/" + keyVaultName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &keyVaultCertificatesOfficerRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	baseWaitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("Key Vault Certificates Officer role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			waitTime := baseWaitTime * time.Duration(attempt)
			log.Printf("Principal not found for Key Vault role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}
