package azure

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"log"
	"math/big"
	"os"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/keyvault/azcertificates"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/authorization/armauthorization"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/dns/armdns"
	"github.com/google/uuid"
	msgraph "github.com/microsoftgraph/msgraph-sdk-go"
	"github.com/microsoftgraph/msgraph-sdk-go/applications"
	"github.com/microsoftgraph/msgraph-sdk-go/models"

	"azure-ssl-certificate-provisioner/internal/types"
)

// Clients holds Azure service clients
type Clients struct {
	DNS        *armdns.RecordSetsClient
	DNSZones   *armdns.ZonesClient
	KVCert     *azcertificates.Client
	Credential *azidentity.DefaultAzureCredential
	Graph      *msgraph.GraphServiceClient
}

// NewClients creates new Azure service clients
func NewClients(subscriptionID, vaultURL string) (*Clients, error) {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to obtain Azure credential: %v", err)
	}

	dnsClient, err := armdns.NewRecordSetsClient(subscriptionID, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create DNS client: %v", err)
	}

	dnsZonesClient, err := armdns.NewZonesClient(subscriptionID, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create DNS zones client: %v", err)
	}

	kvCertClient, err := azcertificates.NewClient(vaultURL, cred, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Key Vault client: %v", err)
	}

	// Request specific Graph API scopes for application management
	graphClient, err := msgraph.NewGraphServiceClientWithCredentials(cred, []string{
		"https://graph.microsoft.com/.default",
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create Graph client: %v", err)
	}

	return &Clients{
		DNS:        dnsClient,
		DNSZones:   dnsZonesClient,
		KVCert:     kvCertClient,
		Credential: cred,
		Graph:      graphClient,
	}, nil
}

// CreateServicePrincipal creates a new Azure AD application and service principal
func (c *Clients) CreateServicePrincipal(displayName, tenantID, subscriptionID string, assignDNSRole bool, resourceGroupName, keyVaultName, keyVaultResourceGroup string, noRoles bool, useCertAuth bool) (*types.ServicePrincipalInfo, error) {
	// Validate provided tenant and subscription IDs
	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID is required")
	}
	if subscriptionID == "" {
		return nil, fmt.Errorf("subscription ID is required")
	}

	// Create the service principal info struct early and populate it as we go
	spInfo := &types.ServicePrincipalInfo{
		SubscriptionID: subscriptionID,
		TenantID:       tenantID,
		UseCertAuth:    useCertAuth,
	}

	// Create the Azure AD application
	application := models.NewApplication()
	application.SetDisplayName(&displayName)

	createdApp, err := c.Graph.Applications().Post(context.Background(), application, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create Azure AD application: %v", err)
	}

	if createdApp.GetId() == nil || createdApp.GetAppId() == nil {
		return nil, fmt.Errorf("failed to get application IDs")
	}

	spInfo.ApplicationID = *createdApp.GetId()
	spInfo.ClientID = *createdApp.GetAppId()

	// Create service principal for the application
	servicePrincipal := models.NewServicePrincipal()
	servicePrincipal.SetAppId(createdApp.GetAppId())

	createdSP, err := c.Graph.ServicePrincipals().Post(context.Background(), servicePrincipal, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create service principal: %v", err)
	}

	if createdSP.GetId() == nil {
		return nil, fmt.Errorf("failed to get service principal ID")
	}

	spInfo.ServicePrincipalID = *createdSP.GetId()

	if useCertAuth {
		// Derive certificate and private key paths from client ID
		privateKeyPath := fmt.Sprintf("%s.key", spInfo.ClientID)
		certificatePath := fmt.Sprintf("%s.crt", spInfo.ClientID)
		spInfo.PrivateKeyPath = privateKeyPath
		spInfo.CertificatePath = certificatePath

		// Use certificate-based authentication
		err := c.setupCertificateAuth(spInfo.ApplicationID, privateKeyPath, certificatePath)
		if err != nil {
			return nil, fmt.Errorf("failed to setup certificate authentication: %v", err)
		}
		log.Printf("Certificate authentication configured for application: key=%s, cert=%s", privateKeyPath, certificatePath)
	} else {
		// Create client secret
		passwordCredential := models.NewPasswordCredential()
		displayNameStr := "Generated by azure-ssl-certificate-provisioner"
		passwordCredential.SetDisplayName(&displayNameStr)

		addPasswordRequest := applications.NewItemAddPasswordPostRequestBody()
		addPasswordRequest.SetPasswordCredential(passwordCredential)

		secret, err := c.Graph.Applications().ByApplicationId(spInfo.ApplicationID).AddPassword().Post(context.Background(), addPasswordRequest, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to create client secret: %v", err)
		}

		if secret.GetSecretText() == nil {
			return nil, fmt.Errorf("failed to get client secret")
		}
		spInfo.ClientSecret = *secret.GetSecretText()
	}

	// Skip role assignments if noRoles is true
	if noRoles {
		log.Printf("Role assignments skipped due to noRoles parameter")
	} else {
		// Optionally assign DNS Zone Contributor role
		if assignDNSRole && resourceGroupName != "" {
			if err := c.assignDNSZoneContributorRole(spInfo, resourceGroupName); err != nil {
				log.Printf("DNS Zone Contributor role assignment failed: resource_group=%s, error=%v", resourceGroupName, err)
			} else {
				log.Printf("DNS Zone Contributor role assigned: resource_group=%s", resourceGroupName)
			}
		}

		// Optionally assign Key Vault Certificates Officer role
		if keyVaultName != "" && keyVaultResourceGroup != "" {
			if err := c.assignKeyVaultCertificatesOfficerRole(spInfo, keyVaultName, keyVaultResourceGroup); err != nil {
				log.Printf("Key Vault Certificates Officer role assignment failed: key_vault=%s, error=%v", keyVaultName, err)
			} else {
				log.Printf("Key Vault Certificates Officer role assigned: key_vault=%s", keyVaultName)
			}
		}
	}

	return spInfo, nil
}

func (c *Clients) assignDNSZoneContributorRole(spInfo *types.ServicePrincipalInfo, resourceGroupName string) error {
	clientOptions := &arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			APIVersion: "2022-04-01",
		},
	}
	authClient, err := armauthorization.NewRoleAssignmentsClient(spInfo.SubscriptionID, c.Credential, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to create authorization client: %v", err)
	}

	// DNS Zone Contributor role ID
	dnsZoneContributorRoleID := "/subscriptions/" + spInfo.SubscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/befefa01-2a29-4197-83a8-272ff33ce314"

	// Resource group scope
	scope := "/subscriptions/" + spInfo.SubscriptionID + "/resourceGroups/" + resourceGroupName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &dnsZoneContributorRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	baseWaitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("DNS Zone Contributor role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			waitTime := baseWaitTime * time.Duration(attempt)
			log.Printf("Principal not found for DNS role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

func (c *Clients) assignKeyVaultCertificatesOfficerRole(spInfo *types.ServicePrincipalInfo, keyVaultName, keyVaultResourceGroup string) error {
	clientOptions := &arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			APIVersion: "2022-04-01",
		},
	}
	authClient, err := armauthorization.NewRoleAssignmentsClient(spInfo.SubscriptionID, c.Credential, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to create authorization client: %v", err)
	}

	// Key Vault Certificates Officer role ID
	keyVaultCertificatesOfficerRoleID := "/subscriptions/" + spInfo.SubscriptionID + "/providers/Microsoft.Authorization/roleDefinitions/a4417e6f-fecd-4de8-b567-7b0420556985"

	// Key Vault scope
	scope := "/subscriptions/" + spInfo.SubscriptionID + "/resourceGroups/" + keyVaultResourceGroup + "/providers/Microsoft.KeyVault/vaults/" + keyVaultName

	// Generate a unique role assignment ID
	roleAssignmentID := uuid.New().String()

	roleAssignmentProperties := armauthorization.RoleAssignmentCreateParameters{
		Properties: &armauthorization.RoleAssignmentProperties{
			RoleDefinitionID: &keyVaultCertificatesOfficerRoleID,
			PrincipalID:      &spInfo.ServicePrincipalID,
		},
	}

	// Retry role assignment if PrincipalNotFound error occurs
	maxRetries := 5
	baseWaitTime := time.Second

	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = authClient.Create(context.Background(), scope, roleAssignmentID, roleAssignmentProperties, nil)
		if err == nil {
			if attempt > 1 {
				log.Printf("Key Vault Certificates Officer role assignment succeeded after %d attempt(s)", attempt)
			}
			return nil
		}

		// Check if this is a PrincipalNotFound error
		if strings.Contains(err.Error(), "PrincipalNotFound") || strings.Contains(err.Error(), "does not exist") {
			if attempt == maxRetries {
				return fmt.Errorf("failed to create role assignment after %d attempts, principal not found: %v", maxRetries, err)
			}

			waitTime := baseWaitTime * time.Duration(attempt)
			log.Printf("Principal not found for Key Vault role assignment (attempt %d/%d), waiting %v before retry",
				attempt, maxRetries, waitTime)
			time.Sleep(waitTime)
			continue
		}

		// For other errors, don't retry
		return fmt.Errorf("failed to create role assignment: %v", err)
	}

	return nil
}

// setupCertificateAuth generates a self-signed certificate and configures certificate-based authentication
func (c *Clients) setupCertificateAuth(applicationID, privateKeyPath, certificatePath string) error {
	// Generate self-signed certificate and private key
	cert, privateKey, err := c.generateSelfSignedCertificate(applicationID)
	if err != nil {
		return fmt.Errorf("failed to generate self-signed certificate: %v", err)
	}

	// Save private key to file
	privateKeyPEM := c.encodePrivateKeyToPEM(privateKey)
	err = os.WriteFile(privateKeyPath, privateKeyPEM, 0600)
	if err != nil {
		return fmt.Errorf("failed to write private key file: %v", err)
	}
	log.Printf("Private key saved to: %s", privateKeyPath)

	// Save certificate to file
	certPEM := c.encodeCertificateToPEM(cert)
	err = os.WriteFile(certificatePath, certPEM, 0644)
	if err != nil {
		return fmt.Errorf("failed to write certificate file: %v", err)
	}
	log.Printf("Certificate saved to: %s", certificatePath)

	// Upload the certificate to Azure AD Application to enable certificate authentication
	keyCredential := models.NewKeyCredential()

	// Set certificate data (raw DER bytes)
	keyCredential.SetKey(cert.Raw)

	// Set required properties for certificate authentication
	displayName := "Generated certificate by azure-ssl-certificate-provisioner"
	keyCredential.SetDisplayName(&displayName)

	// Set the type to AsymmetricX509Cert as required by Azure AD
	credType := "AsymmetricX509Cert"
	keyCredential.SetTypeEscaped(&credType)

	// Set usage for certificate authentication
	usage := "Verify"
	keyCredential.SetUsage(&usage)

	// Set start and end dates from the certificate
	startDateTime := cert.NotBefore
	endDateTime := cert.NotAfter
	keyCredential.SetStartDateTime(&startDateTime)
	keyCredential.SetEndDateTime(&endDateTime)

	log.Printf("Uploading certificate to Azure AD application: %s", applicationID)
	log.Printf("Certificate subject: %s", cert.Subject.String())
	log.Printf("Certificate valid from: %s to %s", cert.NotBefore.Format(time.RFC3339), cert.NotAfter.Format(time.RFC3339))

	// Add a small delay to ensure application is fully created
	time.Sleep(2 * time.Second)

	// Try to update the application's keyCredentials directly instead of using AddKey
	existingApp, err := c.Graph.Applications().ByApplicationId(applicationID).Get(context.Background(), nil)
	if err != nil {
		return fmt.Errorf("failed to retrieve application for certificate update (appId: %s): %v", applicationID, err)
	}

	// Get existing keyCredentials and append the new one
	existingKeyCreds := existingApp.GetKeyCredentials()
	if existingKeyCreds == nil {
		existingKeyCreds = []models.KeyCredentialable{}
	}
	updatedKeyCreds := append(existingKeyCreds, keyCredential)

	// Update the application with the new keyCredentials
	updateApp := models.NewApplication()
	updateApp.SetKeyCredentials(updatedKeyCreds)

	_, err = c.Graph.Applications().ByApplicationId(applicationID).Patch(context.Background(), updateApp, nil)
	if err != nil {
		return fmt.Errorf("failed to upload certificate to Azure AD application (appId: %s): %v", applicationID, err)
	}

	log.Printf("Certificate successfully uploaded to Azure AD application")
	log.Printf("Certificate files generated for service principal authentication:")
	log.Printf("  Private Key: %s", privateKeyPath)
	log.Printf("  Certificate: %s", certificatePath)

	return nil
}

// generateSelfSignedCertificate generates a self-signed certificate and private key
func (c *Clients) generateSelfSignedCertificate(applicationID string) (*x509.Certificate, *rsa.PrivateKey, error) {
	// Generate RSA private key
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate private key: %v", err)
	}

	// Create certificate template
	template := x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName:   fmt.Sprintf("azure-ssl-cert-provisioner-%s", applicationID),
			Organization: []string{"Azure SSL Certificate Provisioner"},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour), // 1 year
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
		BasicConstraintsValid: true,
	}

	// Create the certificate
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create certificate: %v", err)
	}

	// Parse the certificate
	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse certificate: %v", err)
	}

	return cert, privateKey, nil
}

// encodePrivateKeyToPEM encodes a private key to PEM format
func (c *Clients) encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte {
	privateKeyDER := x509.MarshalPKCS1PrivateKey(privateKey)
	privateKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: privateKeyDER,
	})
	return privateKeyPEM
}

// encodeCertificateToPEM encodes a certificate to PEM format
func (c *Clients) encodeCertificateToPEM(cert *x509.Certificate) []byte {
	certPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: cert.Raw,
	})
	return certPEM
}
